diff -r 8de071d14da3 h264dec/Makefile.am
--- a/h264dec/Makefile.am	Thu Mar 14 14:50:42 2013 +0100
+++ b/h264dec/Makefile.am	Thu Mar 21 11:20:51 2013 +0100
@@ -1,6 +1,6 @@
 AM_CFLAGS = -std=gnu99 -Wall -Werror
 AM_LDFLAGS =
-SUBDIRS = libavutil libavcodec
+SUBDIRS = libavutil libavcodec libport
 bin_PROGRAMS = h264dec
 h264dec_SOURCES = h264dec.c
 
@@ -9,7 +9,7 @@
 endif
 
 OPENCL_LIB = libavcodec/opencl/libavcodec_opencl.a
-
+PORT_LIB =libport/libport.a
 if HAVE_CUDA
 CUDA_LIB = libavcodec/cuda/libavcodec_cuda.a
 endif
@@ -19,4 +19,4 @@
 CELL_SYNC_LIB=/opt/cell/sdk/usr/lib/libsync.a
 endif
 
-h264dec_LDADD = $(OPENCL_LIB) libavcodec/libavcodec.a $(ARCH_LIB) libavutil/libavutil.a $(CELL_SYNC_LIB) $(CUDA_LIB)
+h264dec_LDADD = $(OPENCL_LIB) libavcodec/libavcodec.a $(ARCH_LIB) libavutil/libavutil.a $(CELL_SYNC_LIB) $(CUDA_LIB) $(PORT_LIB)
diff -r 8de071d14da3 h264dec/configure.ac
--- a/h264dec/configure.ac	Thu Mar 14 14:50:42 2013 +0100
+++ b/h264dec/configure.ac	Thu Mar 21 11:20:51 2013 +0100
@@ -173,6 +173,6 @@
 
 AC_CONFIG_HEADER([config.h])
 
-AC_CONFIG_FILES([Makefile libavcodec/opencl/Makefile libavcodec/cuda/Makefile libavutil/Makefile libavcodec/Makefile libavcodec/x86/Makefile libavcodec/ppc/Makefile libavcodec/cell/Makefile])
+AC_CONFIG_FILES([Makefile libavcodec/opencl/Makefile libavcodec/cuda/Makefile libport/Makefile libavutil/Makefile libavcodec/Makefile libavcodec/x86/Makefile libavcodec/ppc/Makefile libavcodec/cell/Makefile])
 
 AC_OUTPUT
diff -r 8de071d14da3 h264dec/h264dec.c
--- a/h264dec/h264dec.c	Thu Mar 14 14:50:42 2013 +0100
+++ b/h264dec/h264dec.c	Thu Mar 21 11:20:51 2013 +0100
@@ -15,10 +15,8 @@
 #include <fcntl.h>
 
 #include <sys/types.h>
-#include <sys/time.h>
 #include <sys/resource.h>
-#include <time.h>
-
+#include "libport/getRealTime.h"
 #include <assert.h>
 
 static const char program_name[] = "h264dec";
@@ -257,8 +255,8 @@
 
 int main(int argc, char **argv)
 {
-	struct timespec end ,start;
-	clock_gettime(CLOCK_REALTIME, &start);
+	double end ,start;
+    getRealTime(&start);
     /* parse options */
     parse_cmd(argc, argv);
 
@@ -299,8 +297,8 @@
     free_h264dec_context(h);
     close(ifile);
     close(ofile);
-    clock_gettime(CLOCK_REALTIME, &end);
-    double total_time = (double) (1.e3*(end.tv_sec - start.tv_sec) + 1.e-6*(end.tv_nsec - start.tv_nsec));
+    getRealTime(&end);
+    double total_time = (double) (end-start)*1.e-6;
 	if(h->profile==3){
 		//Others includes parse time and other sync.
 		switch(gpumode){
diff -r 8de071d14da3 h264dec/libavcodec/h264.c
--- a/h264dec/libavcodec/h264.c	Thu Mar 14 14:50:42 2013 +0100
+++ b/h264dec/libavcodec/h264.c	Thu Mar 21 11:20:51 2013 +0100
@@ -3,6 +3,7 @@
 #include "h264_misc.h"
 #include <math.h>
 #include "opencl/h264_idct_opencl.h"
+#include "../libport/getRealTime.h"
 H264Context *get_h264dec_context(const char *file_name, int ifile, int ofile, int width, int height, h264_options *opts){
     int i;
     const int mb_height = (height + 15) / 16;
@@ -78,7 +79,7 @@
     h->rl_q.fi = h->rl_q.fo= 0;
     h->rl_q.queue = av_malloc(h->rl_q.size* sizeof(RingLineEntry*));
     for (i=0; i<h->rl_q.size; i++){
-        if( posix_memalign((void**)&h->rl_q.queue[i],64,sizeof(RingLineEntry)))
+        if( aligned_mem((void**)&h->rl_q.queue[i],64,sizeof(RingLineEntry)))
             h->rl_q.queue[i]=NULL;
         h->rl_q.queue[i]->top = av_malloc(h->mb_width*sizeof(TopBorder));
     }
diff -r 8de071d14da3 h264dec/libavcodec/h264_gpu.c
--- a/h264dec/libavcodec/h264_gpu.c	Thu Mar 14 14:50:42 2013 +0100
+++ b/h264dec/libavcodec/h264_gpu.c	Thu Mar 21 11:20:51 2013 +0100
@@ -17,7 +17,7 @@
 #include "cuda/h264_cuda.h"
 #include "cuda/h264_mc_cuda.h"
 #include "cuda/h264_idct_cuda.h"
-
+#include "../libport/getRealTime.h"
 int gpumode=0;
 double idct_gpu_time=0.0;
 double mc_total_time[MC_PROFILE_PHASES]=  {0.0,};
@@ -128,10 +128,10 @@
 
 static void decode_slice_gpu(H264Context *h, MBRecContext *d, H264Slice *s2, H264Mb *mbs, SliceBufferEntry *sbe){
     //motion compensation only works for P and B slice_type
-    struct timespec timestamps[MC_PROFILE_PHASES+1];
+    double timestamps[MC_PROFILE_PHASES+1];
     int stamp_idx=0;
     if(h->profile==3)
-        clock_gettime(CLOCK_REALTIME, &timestamps[stamp_idx++]);
+        getRealTime(&timestamps[stamp_idx++]);
     for (int i=0; i<2; i++){
         for(int j=0; j< s2->ref_count[i]; j++){
             if (s2->ref_list_cpn[i][j] ==-1)
@@ -197,9 +197,9 @@
                         }
                     }
                     if(h->profile==3){
-                       //FIXME: Note the MC_OVERHEAD time is included in the MC time
-                       clock_gettime(CLOCK_REALTIME, &timestamps[stamp_idx]);
-                       mc_total_time[MC_OVERHEAD] += getmillisecond(timestamps[stamp_idx],timestamps[stamp_idx-1]);
+                       //NOTE: Note the MC_OVERHEAD time is included in the MC time
+                       getRealTime(&timestamps[stamp_idx]);
+                       mc_total_time[MC_OVERHEAD] += (timestamps[stamp_idx]-timestamps[stamp_idx-1])*1.e-6;
                     }
                     //launch motion compensation kernel
                     myGPUEnv[ARCH_NVIDIA_CUDA].gpu_mc(h, d,s2,sbe);
@@ -214,8 +214,8 @@
                     }
                 }
                 if(h->profile==3){
-                    clock_gettime(CLOCK_REALTIME, &timestamps[stamp_idx++]);
-                    mc_total_time[MC_TIME] += getmillisecond(timestamps[stamp_idx-1],timestamps[stamp_idx-2]);
+                    getRealTime(&timestamps[stamp_idx++]);
+                    mc_total_time[MC_TIME] += (timestamps[stamp_idx-1]-timestamps[stamp_idx-2])*1.e-6;
                 }
                 if(gpumode==CPU_BASELINE_TOTAL||gpumode==GPU_TOTAL){
                     for(int j=0; j<d->mb_height; j++){
@@ -238,8 +238,8 @@
                 }
             }
             if(h->profile==3){
-               clock_gettime(CLOCK_REALTIME, &timestamps[stamp_idx++]);
-                mc_total_time[INTRADF] += getmillisecond(timestamps[stamp_idx-1],timestamps[stamp_idx-2]);
+                getRealTime(&timestamps[stamp_idx++]);
+                mc_total_time[INTRADF] += (timestamps[stamp_idx-1]-timestamps[stamp_idx-2])*1.e-6;
             }
         }
 
@@ -293,8 +293,8 @@
         }        
     }
     if(h->profile==3){
-        clock_gettime(CLOCK_REALTIME,&timestamps[stamp_idx++]);
-        mc_total_time[MC_TAIL]+=getmillisecond(timestamps[stamp_idx-1],timestamps[stamp_idx-2]);
+        getRealTime(&timestamps[stamp_idx++]);
+        mc_total_time[MC_TAIL]+=(timestamps[stamp_idx-1]-timestamps[stamp_idx-2])*1.e-6;
     }
     curslice++;
 }
@@ -359,17 +359,17 @@
             //wait until there is another IDCT Compressed Buffer available 
             decode_slice_entropy(ec, sbe);
             if ((gpumode>=CPU_BASELINE_IDCT)&&(gpumode!=CPU_BASELINE_MC)&&(gpumode!=GPU_MC)&&(gpumode!=GPU_MC_NOVERLAP)){
-                struct timespec timestamps[2];
+                double timestamps[2];
                 if(h->profile==3){
-                    clock_gettime(CLOCK_REALTIME, &timestamps[0]);
+                    getRealTime(&timestamps[0]);
                 }
                 if((gpumode==GPU_IDCT)||(gpumode==GPU_TOTAL))
                     myGPUEnv[ARCH_NVIDIA_CUDA].gpu_idct(h);
                 if((gpumode==CPU_BASELINE_IDCT)||(gpumode==CPU_BASELINE_TOTAL))
                     cpu_slice_idct(h);
                 if(h->profile==3){
-                    clock_gettime(CLOCK_REALTIME, &timestamps[1]);
-                    idct_gpu_time += (double)(1.e3*(timestamps[1].tv_sec-timestamps[0].tv_sec)+1.e-6*(timestamps[1].tv_nsec-timestamps[0].tv_nsec));
+                    getRealTime(&timestamps[1]);
+                    idct_gpu_time += (timestamps[1]-timestamps[0])*1.e-6;
                 }
                 pthread_mutex_lock(&IDCT_Mem_queue.lock);
                 while(IDCT_Mem_queue.cnt>=IDCT_Mem_queue.size)
@@ -470,17 +470,17 @@
 int h264_decode_gpu(H264Context *h) {
 //     put the simplified version of h264_decode_pthread    
     pthread_t parse_thr,entropy_thr, rec_thr ,output_thr;
-    struct timespec gpuEnv[2];
+    double gpuEnv[2];
     double env_time;
     if(gpumode>CPU_BASELINE_TOTAL){
-        clock_gettime(CLOCK_REALTIME, &gpuEnv[0]);
+        getRealTime(&gpuEnv[0]);
         myGPUEnv[ARCH_NVIDIA_CUDA].gpu_construct_environment(h);
     }
     if(gpumode==CPU_BASELINE_IDCT||gpumode==CPU_BASELINE_TOTAL)
         idct_cpu_mem_construct(h);
     if(gpumode>CPU_BASELINE_TOTAL){
-        clock_gettime(CLOCK_REALTIME, &gpuEnv[1]);
-        env_time = getmillisecond(gpuEnv[1],gpuEnv[0]);
+        getRealTime(&gpuEnv[1]);
+        env_time = (gpuEnv[1]-gpuEnv[0])*1.e-6;
         printf("gpu Env %.3f\n", env_time);
     }
     av_start_timer();
diff -r 8de071d14da3 h264dec/libavcodec/h264_misc.c
--- a/h264dec/libavcodec/h264_misc.c	Thu Mar 14 14:50:42 2013 +0100
+++ b/h264dec/libavcodec/h264_misc.c	Thu Mar 21 11:20:51 2013 +0100
@@ -4,8 +4,6 @@
 
 #include <unistd.h>
 #include <sys/resource.h>
-#include <sys/time.h>
-#include <time.h>
 #include <pthread.h>
 #undef NDEBUG
 #include <assert.h>
@@ -17,13 +15,16 @@
 #endif
 #endif
 
+#include "../libport/getRealTime.h"
+
 void start_timer(H264Context *h, int stage){
-    clock_gettime(CLOCK_REALTIME, &h->start_time[stage]);
+     getRealTime(&h->start_time[stage]);
 }
 
 void stop_timer(H264Context *h, int stage){
-    clock_gettime(CLOCK_REALTIME, &h->end_time[stage]);
-    double time = (double) 1.e3*(h->end_time[stage].tv_sec - h->start_time[stage].tv_sec) + 1.e-6*(h->end_time[stage].tv_nsec - h->start_time[stage].tv_nsec);
+    double stoptime;
+    getRealTime(&stoptime);
+    double time = (stoptime-h->start_time[stage])*1.e-6;
     h->last_time [stage]  = time;
     h->total_time[stage] += time;
 }
@@ -235,11 +236,11 @@
     }
 }
 
-static int64_t timer_start;
+static double timer_start;
 int64_t av_gettime(void) {
-    struct timeval tv;
-    gettimeofday(&tv,NULL);
-    return (int64_t)tv.tv_sec * 1000000 + tv.tv_usec;
+    double tv;
+    getRealTime(&tv);
+    return tv*1.e-3;
 }
 
 void av_start_timer(){
@@ -247,19 +248,19 @@
 }
 
 void print_report(int frame_number, uint64_t video_size, int is_last_report, int verbose) {
-    static int64_t last_time = -1;
-    static int64_t last_frame_number = 0;
-    float t=0, t2=0;
-    int64_t cur_time=0;
+    double last_time = -1.0;
+    double last_frame_number = 0.0;
+    double t=0, t2=0;
+    double cur_time=0;
     
     if (!is_last_report) {    
         /* display the report every 0.5 seconds */
         cur_time = av_gettime();
-        if (last_time == -1) {
+        if (last_time<-0.9999&&last_time>-1.001) {
             last_time = cur_time;
             return;
         }
-        if ((cur_time - last_time) < 500000)
+        if ((cur_time - last_time) < 500000.0)
             return;
         t = (cur_time-timer_start) / 1000000.0;
         t2 = (cur_time-last_time) / 1000000.0;        
diff -r 8de071d14da3 h264dec/libavcodec/h264_pthread.c
--- a/h264dec/libavcodec/h264_pthread.c	Thu Mar 14 14:50:42 2013 +0100
+++ b/h264dec/libavcodec/h264_pthread.c	Thu Mar 21 11:20:51 2013 +0100
@@ -13,6 +13,7 @@
 #define XOANON 1
 
 #ifdef XOANON
+	#if defined(_POSIX_VERSION)
 static int ed_rec_affinity[40] = { 0,  4,  8, 12, 16, 20, 24, 28, 32, 36,
                                    1,  5,  9, 13, 17, 21, 25, 29, 33, 37,
                                    2,  6, 10, 14, 18, 22, 26, 30, 34, 38,
@@ -21,6 +22,7 @@
                                    1,  41,  5, 45,  9, 49, 13, 53, 17, 57, 21, 61, 25, 65, 29, 69, 33, 73, 37, 77,
                                    2,  42,  6, 46, 10, 50, 14, 54, 18, 58, 22, 62, 26, 66, 30, 70, 34, 74, 38, 78,
                                    3,  43,  7, 47, 11, 51, 15, 55, 19, 59, 23, 63, 27, 67, 31, 71, 35, 75, 39, 79 };
+	#endif
 #else
 static int ed_rec_affinity[10] = { 0,  1,  2,  3,  4,  5,  6,  7,  8,  9};
 static int ed_rec_smt_aff[20] = { 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, };
@@ -474,6 +476,7 @@
 }
 
 void create_ed_rec_threads(H264Context *h){
+	#if defined(_POSIX_VERSION)
     cpu_set_t cpuset;
     int* aff;
 
@@ -487,10 +490,13 @@
             pthread_create(&h->ed_rec_thr[i], &h->ed_rec_attr[i], ed_rec_thread, h);
         }
     } else {
+	#endif
         for (int i=0; i<h->threads; i++){
             pthread_create(&h->ed_rec_thr[i], NULL, ed_rec_thread, h);
         }
-    }
+	#if defined(_POSIX_VERSION)
+    }
+	#endif
 }
 
 void join_ed_rec_threads(H264Context *h){
diff -r 8de071d14da3 h264dec/libavcodec/h264_types.h
--- a/h264dec/libavcodec/h264_types.h	Thu Mar 14 14:50:42 2013 +0100
+++ b/h264dec/libavcodec/h264_types.h	Thu Mar 21 11:20:51 2013 +0100
@@ -648,8 +648,8 @@
     SDLContext *sdlc;
 #endif
      
-    struct timespec start_time[PROFILE_STAGES];
-    struct timespec end_time[PROFILE_STAGES];
+    double start_time[PROFILE_STAGES];
+    double end_time[PROFILE_STAGES];
     double last_time[PROFILE_STAGES];
     double total_time[PROFILE_STAGES];
 
diff -r 8de071d14da3 h264dec/libavcodec/opencl/h264_idct_opencl.c
--- a/h264dec/libavcodec/opencl/h264_idct_opencl.c	Thu Mar 14 14:50:42 2013 +0100
+++ b/h264dec/libavcodec/opencl/h264_idct_opencl.c	Thu Mar 21 11:20:51 2013 +0100
@@ -1,6 +1,5 @@
 #include <stdio.h>
 #include <unistd.h>
-#include <time.h>
 #include "../h264.h"
 #include "../h264_pred_mode.h"
 #include "h264_idct_opencl.h"
diff -r 8de071d14da3 h264dec/libavcodec/opencl/h264_mc_opencl.c
--- a/h264dec/libavcodec/opencl/h264_mc_opencl.c	Thu Mar 14 14:50:42 2013 +0100
+++ b/h264dec/libavcodec/opencl/h264_mc_opencl.c	Thu Mar 21 11:20:51 2013 +0100
@@ -2,7 +2,6 @@
 #include "h264_idct_opencl.h"
 #include <stdio.h>
 #include <unistd.h>
-#include <time.h>
 #include "../h264.h"
 
 /********************************************Add By Biao Wang to support OpenCL***************************************/
@@ -246,14 +245,15 @@
 
 void gpu_opencl_mc(H264Context *h, MBRecContext *d, H264Slice *s, SliceBufferEntry *sbe){
 	cl_int ciErrNum;
-    struct timespec copy[2];
+    double end,start;
 	//transfer memories shared by chroma and luma components:mb_type,reference_index, as well as luma and chroma reference pictures
-    if(h->profile==3)
-        clock_gettime(CLOCK_REALTIME, &copy[0]);
+    if(h->profile==3){
+        getRealTime(&start);
+    }
     shared_memory_transfer(s);
-    if(h->profile){
-        clock_gettime(CLOCK_REALTIME, &copy[1]);
-        mc_gpu_time[MC_KERNEL_COPY_DATA_STRUCTURE]+= (double) (1.e3*(copy[1].tv_sec - copy[0].tv_sec) + 1.e-6*(copy[1].tv_nsec - copy[0].tv_nsec));
+    if(h->profile==3){
+        getRealTime(&end);
+        mc_gpu_time[MC_KERNEL_COPY_DATA_STRUCTURE]+=1.e-6*(end-start);
     }
 	int weighted_prediction = s->use_weight;
 	mc_cpu_luma_output = s->curr_pic->data[0];
diff -r 8de071d14da3 h264dec/libavcodec/opencl/h264_opencl.c
--- a/h264dec/libavcodec/opencl/h264_opencl.c	Thu Mar 14 14:50:42 2013 +0100
+++ b/h264dec/libavcodec/opencl/h264_opencl.c	Thu Mar 21 11:20:51 2013 +0100
@@ -207,16 +207,21 @@
                 {
                     if(strstr(chBuffer, "NVIDIA") != NULL)
                     {
-		        printf("Used platform %d is %s\n",i,chBuffer);
+						printf("Used platform %d is %s\n",i,chBuffer);
                         *clSelectedPlatformID = clPlatformIDs[i];
                         break;
                     }
-		    if(strstr(chBuffer,"AMD")!=NULL)
-		    {
-			printf("Used platform %d is %s\n",i,chBuffer);		      
-		        *clSelectedPlatformID = clPlatformIDs[i];
-			break;
-		    }
+					if(strstr(chBuffer,"AMD")!=NULL)
+					{
+						printf("Used platform %d is %s\n",i,chBuffer);		      
+						*clSelectedPlatformID = clPlatformIDs[i];
+						break;
+					}
+					printf("find platform anyway %s\n",chBuffer);
+					if(strstr(chBuffer,"INTEL")!=NULL){
+						printf("Used platform %d is %s\n",i,chBuffer);
+						*clSelectedPlatformID = clPlatformIDs[i];
+					}
                 }
             }
 
@@ -283,38 +288,39 @@
 }
 
 static int isrebuild(const char *KernelFilename){
-    cl_int ciErrNum;
-    char sourceFile[100];
-    char binaryFile[100];
-    struct stat64 BufFile;
-    struct stat64 BufBin;
-    int rebuild = 0;
-    int RtFile, RtBin;
-    size_t filesize =0;
-    strcpy(sourceFile,KernelFilename);
-    strcpy(binaryFile,KernelFilename);
-    strcat(binaryFile,"bin");
-  
-    RtFile= stat64(KernelFilename,&BufFile);
-    RtBin = stat64(binaryFile, &BufBin);
-    if (RtFile!=0){
-        fprintf(stderr, "Could not find the kernel source file %s\n", sourceFile);
-        exit(-1);
-    }
-    if (RtBin!=0){
-        FILE *myFile ;
-        myFile = fopen(binaryFile, "rb");
-        if(myFile==NULL){
-            rebuild = 1;
-	}
-    }else{
-    //compare the time stamp of binary file and source file 
-        time_t fileSourceModifiedDate = BufFile.st_mtime;
-        time_t fileBinModifiedDate    = BufBin.st_mtime;
-        if(fileSourceModifiedDate >fileBinModifiedDate)
-          rebuild = 1;
-    }
-    return rebuild;
+//     cl_int ciErrNum;
+//     char sourceFile[100];
+//     char binaryFile[100];
+//     struct stat64 BufFile;
+//     struct stat64 BufBin;
+//     int rebuild = 0;
+//     int RtFile, RtBin;
+//     size_t filesize =0;
+//     strcpy(sourceFile,KernelFilename);
+//     strcpy(binaryFile,KernelFilename);
+//     strcat(binaryFile,"bin");
+//   
+//     RtFile= stat64(KernelFilename,&BufFile);
+//     RtBin = stat64(binaryFile, &BufBin);
+//     if (RtFile!=0){
+//         fprintf(stderr, "Could not find the kernel source file %s\n", sourceFile);
+//         exit(-1);
+//     }
+//     if (RtBin!=0){
+//         FILE *myFile ;
+//         myFile = fopen(binaryFile, "rb");
+//         if(myFile==NULL){
+//             rebuild = 1;
+// 	}
+//     }else{
+//     //compare the time stamp of binary file and source file 
+//         time_t fileSourceModifiedDate = BufFile.st_mtime;
+//         time_t fileBinModifiedDate    = BufBin.st_mtime;
+//         if(fileSourceModifiedDate >fileBinModifiedDate)
+//           rebuild = 1;
+//     }
+//     return rebuild;
+    return 1;
 }
 void BuildProgram(const char *KernelFilename, cl_program *CreatedProgram){
     cl_int ciErrNum;
@@ -405,7 +411,7 @@
             printf("\nWriting ptx to separate file: %s ...\n\n", cPtxFileName);
             FILE* pFileStream = NULL;
             #ifdef _WIN32
-                fopen_s(&pFileStream, cPtxFileName, "wb");
+                pFileStream = fopen(cPtxFileName, "wb");
             #else
                 pFileStream = fopen(cPtxFileName, "wb");
             #endif
diff -r 8de071d14da3 h264dec/libavcodec/opencl/h264_opencl.h
--- a/h264dec/libavcodec/opencl/h264_opencl.h	Thu Mar 14 14:50:42 2013 +0100
+++ b/h264dec/libavcodec/opencl/h264_opencl.h	Thu Mar 21 11:20:51 2013 +0100
@@ -4,9 +4,6 @@
 #include "../cl.h"
 #include "../h264_types.h"
 
-
-#include <time.h>
-
 #define MAX_NUM_FRAME    1000u
 #define DETECT_FRAME 0
 #define TRUE 	1
diff -r 8de071d14da3 h264dec/libavcodec/opencl/kernelIDCT.cl
--- a/h264dec/libavcodec/opencl/kernelIDCT.cl	Thu Mar 14 14:50:42 2013 +0100
+++ b/h264dec/libavcodec/opencl/kernelIDCT.cl	Thu Mar 21 11:20:51 2013 +0100
@@ -1,4 +1,4 @@
-#include "opencl/gpu_common.h"
+#include "gpu_common.h"
 
 
 #define IDCT_BANK_BOUND_IN_SHORT (32*2)
diff -r 8de071d14da3 h264dec/libavcodec/opencl/kernelMC.cl
--- a/h264dec/libavcodec/opencl/kernelMC.cl	Thu Mar 14 14:50:42 2013 +0100
+++ b/h264dec/libavcodec/opencl/kernelMC.cl	Thu Mar 21 11:20:51 2013 +0100
@@ -1,4 +1,4 @@
-#include "opencl/gpu_common.h"
+// #include "opencl/gpu_common.h"
 
 
 #define EDGE_WIDTH 32
@@ -42,8 +42,6 @@
 #define IS_SUB_4X8(a)    ((a)&(MB_TYPE_8x16<<4))
 #define IS_SUB_4X4(a)    ((a)&(MB_TYPE_8x8<<4))
 
-#define DECLARE_ALIGNED(n,t,v)      t __attribute__ ((aligned (n))) v
-
 typedef short int16_t;
 typedef unsigned short uint16_t;
 typedef char int8_t;
@@ -126,80 +124,80 @@
                                          int pic_width,int pic_height, 
                                          int weighted_prediction){
 
-    uint8_t out_c[2][2];
-    int gid= get_group_id(1)*get_num_groups(0)+get_group_id(0);
-    int block = ((get_local_id(1)>>2)<<1)+((get_local_id(0))>>2);
-    int sub_block   = (((get_local_id(1)&2)>>1)<<1)+(((get_local_id(0))&2)>>1);
-
-    int frame_size  = get_num_groups(0)*get_num_groups(1);
-    int shifted_gid = gid+(block*4+sub_block)*frame_size;
-
-    int mb_type = frame_sub_mb_type[gid*4+block];
-    int list[2];
-    int part = 0;
-    if(IS_16X8(mb_type)){
-        part = block>>1;//FIXME when merged, maybe it will not apply as 8x8 smaller blocks part may not be 0 
-    }
-    if(IS_8X16(mb_type)){
-        part = block&1;
-    }
-    list[0] = IS_DIR(mb_type,part,0);
-    list[1] = IS_DIR(mb_type,part,1);
-    __global MVVector *frame_list_vector[2]={frame_list0_vector,frame_list1_vector};
-    __global MCRef    *frame_ref[2]   ={frame_list0_ref,frame_list1_ref};
-    for(int l=0;l<2;l++){
-        if(list[l]){
-            chromaFilter(reference_cb, reference_cr, frame_list_vector[l],frame_ref[l], out_c[l], shifted_gid, pic_width, pic_height);
-        }
-    }
-    int gidout = (get_group_id(1)*get_local_size(1)+get_local_id(1))*pic_width+(get_group_id(0)*get_local_size(0)+get_local_id(0));
-    if(list[0]&&list[1]){
-        int weight0, weight1, weight_offset,refn0, refn1;
-        refn0   = (frame_list0_ref[shifted_gid]&REF_MASK)>>4;
-        refn1   = (frame_list1_ref[shifted_gid]&REF_MASK)>>4;
-        if(use_weight&0x1){
-            weight0 = chroma_weight[refn0*8+0*4+0*2+0];
-            weight1 = chroma_weight[refn1*8+1*4+0*2+0];
-            weight_offset = chroma_weight[refn0*8+0*4+0*2+1]+chroma_weight[refn1*8+1*4+0*2+1];
-            weight_offset = ((weight_offset+1)|1)<<log2_denom;
-            out_c[0][0] = (weight0*out_c[0][0]+weight1*out_c[1][0]+weight_offset)>>(log2_denom+1);
-            UNI_CLIP(output_cb[gidout],out_c[0][0])
-
-            weight0 = chroma_weight[refn0*8+0*4+1*2+0];
-            weight1 = chroma_weight[refn1*8+1*4+1*2+0];
-            weight_offset = chroma_weight[refn0*8+0*4+1*2+1]+chroma_weight[refn1*8+1*4+1*2+1];
-            weight_offset = ((weight_offset+1)|1)<<log2_denom;
-            out_c[0][1] = ((weight0*out_c[0][1]+weight1*out_c[1][1]+weight_offset)>>(log2_denom+1));
-            UNI_CLIP(output_cb[gidout],out_c[0][1])
-
-        }else {
-            weight0=32;
-            if(use_weight) weight0 = implicit_weight[refn0*32+refn1*2];
-            weight1= 64-weight0;
-            weight_offset = 32;
-            out_c[0][0] = ((weight0*out_c[0][0]+weight1*out_c[1][0]+weight_offset)>>6);
-            UNI_CLIP(output_cb[gidout],out_c[0][0])
-
-            out_c[0][1] = ((weight0*out_c[0][1]+weight1*out_c[1][1]+weight_offset)>>6);
-            UNI_CLIP(output_cr[gidout],out_c[0][1])
-        }
-    }else{
-         int l=list[1]?1:0;
-         if(use_weight_chroma==1&&weighted_prediction){
-            int refn = (frame_ref[0][shifted_gid]&REF_MASK)>>4;
-            int list = 0;
-            int weight, weighted_offset;
-            weight = chroma_weight[refn*8+list*4+0*2+0];
-            weighted_offset = chroma_weight[refn*8+list*4+0*2+1];
-            weightedPrediction(log2_denom,weight,weighted_offset, &out_c[l][0]);
+    // uint8_t out_c[2][2];
+    // int gid= get_group_id(1)*get_num_groups(0)+get_group_id(0);
+    // int block = ((get_local_id(1)>>2)<<1)+((get_local_id(0))>>2);
+    // int sub_block   = (((get_local_id(1)&2)>>1)<<1)+(((get_local_id(0))&2)>>1);
+
+    // int frame_size  = get_num_groups(0)*get_num_groups(1);
+    // int shifted_gid = gid+(block*4+sub_block)*frame_size;
+
+    // int mb_type = frame_sub_mb_type[gid*4+block];
+    // int list[2];
+    // int part = 0;
+    // if(IS_16X8(mb_type)){
+        // part = block>>1;//FIXME when merged, maybe it will not apply as 8x8 smaller blocks part may not be 0 
+    // }
+    // if(IS_8X16(mb_type)){
+        // part = block&1;
+    // }
+    // list[0] = IS_DIR(mb_type,part,0);
+    // list[1] = IS_DIR(mb_type,part,1);
+    // __global MVVector *frame_list_vector[2]={frame_list0_vector,frame_list1_vector};
+    // __global MCRef    *frame_ref[2]   ={frame_list0_ref,frame_list1_ref};
+    // for(int l=0;l<2;l++){
+        // if(list[l]){
+            // chromaFilter(reference_cb, reference_cr, frame_list_vector[l],frame_ref[l], out_c[l], shifted_gid, pic_width, pic_height);
+        // }
+    // }
+    // int gidout = (get_group_id(1)*get_local_size(1)+get_local_id(1))*pic_width+(get_group_id(0)*get_local_size(0)+get_local_id(0));
+    // if(list[0]&&list[1]){
+        // int weight0, weight1, weight_offset,refn0, refn1;
+        // refn0   = (frame_list0_ref[shifted_gid]&REF_MASK)>>4;
+        // refn1   = (frame_list1_ref[shifted_gid]&REF_MASK)>>4;
+        // if(use_weight&0x1){
+            // weight0 = chroma_weight[refn0*8+0*4+0*2+0];
+            // weight1 = chroma_weight[refn1*8+1*4+0*2+0];
+            // weight_offset = chroma_weight[refn0*8+0*4+0*2+1]+chroma_weight[refn1*8+1*4+0*2+1];
+            // weight_offset = ((weight_offset+1)|1)<<log2_denom;
+            // out_c[0][0] = (weight0*out_c[0][0]+weight1*out_c[1][0]+weight_offset)>>(log2_denom+1);
+            // UNI_CLIP(output_cb[gidout],out_c[0][0])
+
+            // weight0 = chroma_weight[refn0*8+0*4+1*2+0];
+            // weight1 = chroma_weight[refn1*8+1*4+1*2+0];
+            // weight_offset = chroma_weight[refn0*8+0*4+1*2+1]+chroma_weight[refn1*8+1*4+1*2+1];
+            // weight_offset = ((weight_offset+1)|1)<<log2_denom;
+            // out_c[0][1] = ((weight0*out_c[0][1]+weight1*out_c[1][1]+weight_offset)>>(log2_denom+1));
+            // UNI_CLIP(output_cb[gidout],out_c[0][1])
+
+        // }else {
+            // weight0=32;
+            // if(use_weight) weight0 = implicit_weight[refn0*32+refn1*2];
+            // weight1= 64-weight0;
+            // weight_offset = 32;
+            // out_c[0][0] = ((weight0*out_c[0][0]+weight1*out_c[1][0]+weight_offset)>>6);
+            // UNI_CLIP(output_cb[gidout],out_c[0][0])
+
+            // out_c[0][1] = ((weight0*out_c[0][1]+weight1*out_c[1][1]+weight_offset)>>6);
+            // UNI_CLIP(output_cr[gidout],out_c[0][1])
+        // }
+    // }else{
+         // int l=list[1]?1:0;
+         // if(use_weight_chroma==1&&weighted_prediction){
+            // int refn = (frame_ref[0][shifted_gid]&REF_MASK)>>4;
+            // int list = 0;
+            // int weight, weighted_offset;
+            // weight = chroma_weight[refn*8+list*4+0*2+0];
+            // weighted_offset = chroma_weight[refn*8+list*4+0*2+1];
+            // weightedPrediction(log2_denom,weight,weighted_offset, &out_c[l][0]);
             
-            weight = chroma_weight[refn*8+list*4+1*2+0];
-            weighted_offset = chroma_weight[refn*8+list*4+1*2+1];
-            weightedPrediction(log2_denom,weight,weighted_offset, &out_c[l][1]);
-        }
-         output_cb[gidout]  = out_c[l][0];
-         output_cr[gidout]  = out_c[l][1];
-    }
+            // weight = chroma_weight[refn*8+list*4+1*2+0];
+            // weighted_offset = chroma_weight[refn*8+list*4+1*2+1];
+            // weightedPrediction(log2_denom,weight,weighted_offset, &out_c[l][1]);
+        // }
+         // output_cb[gidout]  = out_c[l][0];
+         // output_cr[gidout]  = out_c[l][1];
+    // }
 }
 
 
@@ -249,11 +247,12 @@
     int localidy = get_local_id(1)*9;
     __local uint8_t *buf_src  = &src[localidx+localidy*64];
     int inner_offset = (col==3);
+	// int i;
     for(int i=0;i<9;i++)
-        dst_F[get_local_id(0)+(localidy+i)*MC_SIZE] = (buf_src+i*SRC_STRIDE)[inner_offset];
-    if(col)
-        for(int i=0;i<9;i++)
-            dst_H[get_local_id(0)+(localidy+i)*MC_SIZE] = TAP6_BASIC_H((buf_src+i*SRC_STRIDE));
+        dst_F[get_local_id(0)+(localidy+i)*MC_SIZE] = buf_src[inner_offset+i*SRC_STRIDE];
+    // if(col)
+        // for(i=0;i<9;i++)
+            // dst_H[get_local_id(0)+(localidy+i)*MC_SIZE] = TAP6_BASIC_H((buf_src+i*SRC_STRIDE));
 }
 
 inline void computeVertical(__local int16_t *dst ,__local int16_t *src, int shift_bits){
@@ -387,28 +386,28 @@
             barrier(CLK_LOCAL_MEM_FENCE);
             copyFullAndComputeHorizontal(buf_F, buf_H, buf_src, MC_SIZE, SRC_STRIDE, align_offset, col, row);
             barrier(CLK_LOCAL_MEM_FENCE);
-            if(row){
-                int inner_offset = (col==2);
-                __local int16_t *H = inner_offset?&buf_H[get_local_id(0)+(get_local_id(1)*9+2)*MC_SIZE]:&buf_F[get_local_id(0)+(get_local_id(1)*9+2)*MC_SIZE];
-                __local int16_t *V  = inner_offset?&buf_HV[get_local_id(0)+get_local_id(1)*4*MC_SIZE]:&buf_V[get_local_id(0)+get_local_id(1)*4*MC_SIZE];
-                computeVertical(V, H, 5<<inner_offset);
-            }
-            if(row==2||(col&1)){
-                __local int16_t *H = &buf_H[get_local_id(0)+(get_local_id(1)*9+2)*MC_SIZE];
-                __local int16_t *V = &buf_HV[get_local_id(0)+get_local_id(1)*4*MC_SIZE];
-                computeVertical(V, H, 10);
-            }
-            barrier(CLK_LOCAL_MEM_FENCE);
-
-            clipHorizontal(buf_H, col, row);
-            barrier(CLK_LOCAL_MEM_FENCE);
-
-            __local int16_t *tmpbufH, *tmpbufV;
-            adjustPointerForAVG(&tmpbufH, &tmpbufV, buf_F, buf_H, buf_V, buf_HV, col, row);
-            int localout   = get_local_id(0)+get_local_id(1)*4*MC_SIZE;
-            for(int i=0;i<4;i++)
-                buf_weight[l][localout+i*MC_SIZE] = (tmpbufH[i*MC_SIZE]+tmpbufV[i*MC_SIZE]+1)>>1;
-            barrier(CLK_LOCAL_MEM_FENCE);
+            // if(row){
+                // int inner_offset = (col==2);
+                // __local int16_t *H = inner_offset?&buf_H[get_local_id(0)+(get_local_id(1)*9+2)*MC_SIZE]:&buf_F[get_local_id(0)+(get_local_id(1)*9+2)*MC_SIZE];
+                // __local int16_t *V  = inner_offset?&buf_HV[get_local_id(0)+get_local_id(1)*4*MC_SIZE]:&buf_V[get_local_id(0)+get_local_id(1)*4*MC_SIZE];
+                // computeVertical(V, H, 5<<inner_offset);
+            // }
+            // if(row==2||(col&1)){
+                // __local int16_t *H = &buf_H[get_local_id(0)+(get_local_id(1)*9+2)*MC_SIZE];
+                // __local int16_t *V = &buf_HV[get_local_id(0)+get_local_id(1)*4*MC_SIZE];
+                // computeVertical(V, H, 10);
+            // }
+            // barrier(CLK_LOCAL_MEM_FENCE);
+
+            // clipHorizontal(buf_H, col, row);
+            // barrier(CLK_LOCAL_MEM_FENCE);
+
+            // __local int16_t *tmpbufH, *tmpbufV;
+            // adjustPointerForAVG(&tmpbufH, &tmpbufV, buf_F, buf_H, buf_V, buf_HV, col, row);
+            // int localout   = get_local_id(0)+get_local_id(1)*4*MC_SIZE;
+            // for(int i=0;i<4;i++)
+                // buf_weight[l][localout+i*MC_SIZE] = (tmpbufH[i*MC_SIZE]+tmpbufV[i*MC_SIZE]+1)>>1;
+            // barrier(CLK_LOCAL_MEM_FENCE);
         }
     }
     int gidout     = gidy*MC_SIZE*pic_width+gidx*MC_SIZE+get_local_id(0)+get_local_id(1)*4*pic_width;
diff -r 8de071d14da3 h264dec/libport/Makefile.am
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/h264dec/libport/Makefile.am	Thu Mar 21 11:20:51 2013 +0100
@@ -0,0 +1,5 @@
+
+AM_CFLAGS = -std=gnu99 -Wall -Werror
+lib_LIBRARIES = libport.a
+libport_a_SOURCES =  getRealTime.c
+libport_a_CPPFLAGS = -I$(top_srcdir)
diff -r 8de071d14da3 h264dec/libport/getRealTime.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/h264dec/libport/getRealTime.c	Thu Mar 21 11:20:51 2013 +0100
@@ -0,0 +1,83 @@
+/*
+ * Author:  David Robert Nadeau
+ * Site:    http://NadeauSoftware.com/
+ * License: Creative Commons Attribution 3.0 Unported License
+ *          http://creativecommons.org/licenses/by/3.0/deed.en_US
+ */
+
+#if defined(_WIN32)
+#include <malloc.h>
+#include <Windows.h>
+
+
+#elif defined(__unix__) || defined(__unix) || defined(unix) || (defined(__APPLE__) && defined(__MACH__))
+#include <unistd.h>	/* POSIX flags */
+#include <time.h>	/* clock_gettime(), time() */
+#include <sys/time.h>	/* gethrtime(), gettimeofday() */
+#include <stdlib.h>
+
+#if defined(__MACH__) && defined(__APPLE__)
+#include <mach/mach.h>
+#include <mach/mach_time.h>
+#endif
+
+#else
+#error "Unable to define getRealTime( ) for an unknown OS."
+#endif
+#include "getRealTime.h"
+/**
+ * Returns the real time, in microseconds, or -1.0 if an error occurred.
+ *
+ * Time is measured since an arbitrary and OS-dependent start time.
+ * The returned real time is only useful for computing an elapsed time
+ * between two calls to this function.
+ */
+void getRealTime(double *value)
+{
+#if defined(_WIN32)
+	FILETIME tm;
+	ULONGLONG t;
+#if defined(NTDDI_WIN8) && NTDDI_VERSION >= NTDDI_WIN8
+	/* Windows 8, Windows Server 2012 and later. ---------------- */
+	GetSystemTimePreciseAsFileTime( &tm );
+#else
+	/* Windows 2000 and later. ---------------------------------- */
+	GetSystemTimeAsFileTime( &tm );
+#endif
+	t = ((ULONGLONG)tm.dwHighDateTime << 32) | (ULONGLONG)tm.dwLowDateTime;
+	*value = (double)t*100;
+	return ;
+
+#elif defined(_POSIX_VERSION)
+	/* POSIX. --------------------------------------------------- */
+#if defined(_POSIX_TIMERS) && (_POSIX_TIMERS > 0)
+	{
+        struct timespec ts;
+        int ret = clock_gettime(CLOCK_REALTIME, &ts);
+        if ( ret!= -1 ){
+            *value = ((double)ts.tv_sec)*1.e9+((double)ts.tv_nsec);
+            return;
+        }
+
+		/* Fall thru. */
+	}
+#endif /* _POSIX_TIMERS */
+	/* AIX, BSD, Cygwin, HP-UX, Linux, OSX, POSIX, Solaris. ----- */
+    printf("getRealTime failed\n");
+#endif
+}
+
+int aligned_mem(void **memptr, size_t alignment, size_t size){
+#if defined(_WIN32)
+    void *tmp=NULL;
+    tmp = _aligned_malloc(size,alignment);
+    *memptr = tmp;
+	static int a=0;
+	printf("Add tmp 0x%x %d\n",(int )tmp,a++);
+    return tmp==NULL?1:0;
+#elif defined(_POSIX_VERSION)
+    /* POSIX. --------------------------------------------------- */
+    return posix_memalign(memptr,alignment, size);
+#endif
+    
+}
diff -r 8de071d14da3 h264dec/libport/getRealTime.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/h264dec/libport/getRealTime.h	Thu Mar 21 11:20:51 2013 +0100
@@ -0,0 +1,6 @@
+#ifndef GETREALTIME_H
+#define GETREALTIME_H
+#include<stdio.h>
+void getRealTime(double *value);
+int aligned_mem(void **memptr, size_t alignment, size_t size);
+#endif
\ No newline at end of file
